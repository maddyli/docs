---
title: "FHIR Batch Requests"
description: "FHIR allows users to create batch requests to bundle multiple API calls into a single HTTP request. Batch requests can improve speed and efficiency and can reduce HTTP traffic when working with many resources."
---

<Check>
  If you want to create a copy of a project, say for a new environment, this can be done using the `$clone` operation rather than by creating a batch request. For more details [see the Projects guide](/docs/access/projects#cloning-and-expunging-projects).
</Check>

## Batches vs Transactions[​](#batches-vs-transactions "Direct link to Batches vs Transactions")

When bundling multiple operations together, FHIR provides two modes of operation controlled by the `Bundle.type` field:

* `batch`: Each operation in the bundle is processed independently. Some operations may succeed while others fail. This is useful when the operations are not dependent on each other.
* `transaction`: All operations in the bundle are processed atomically - either all operations succeed, or none of them do. This ensures data consistency when operations are dependent on each other.

Here's a simple example showing the difference:

```
// Batch example - operations processed independentlyconst batchBundle = {  resourceType: 'Bundle',  type: 'batch',  entry: [    /* operations */  ],};// Transaction example - operations processed atomicallyconst transactionBundle = {  resourceType: 'Bundle',  type: 'transaction',  entry: [    /* operations */  ],};
```

<Warning>
  Transaction support requires the `transaction-bundles` feature flag to be enabled on your project. Contact Medplum to enable this feature.

  The transaction feature is currently in beta. You may experience `409 conflict` errors when attempting transactions. If this occurs, implement retry logic in your client to handle these errors and retry the transaction until it succeeds.
</Warning>

## How to Perform a Batch Request[​](#how-to-perform-a-batch-request "Direct link to How to Perform a Batch Request")

Batch requests are performed by sending a POST request to `[baseURL]/` with a FHIR Bundle. The Medplum SDK provides the `executeBatch` helper function to simplify this operation.

The details of your request will be in the `entry` field of the `Bundle`, which is an array of `BundleEntry` objects. Each `BundleEntry` should have the details of the resource you are working with, as well as additional information about the request you are making.

| Element               | Description                                                                                                                                                                                    |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `request.url`         | The URL to send your request to. This is relative to the base R4 FHIR URL (e.g. [https://api.medplum.com/fhir/R4](https://api.medplum.com/fhir/R4)).                                           |
| `request.method`      | The type of HTTP request you are making. Can be one of the following:- GET: Read a resource or perform a search
- POST: Create a resource
- PUT: Update a resource
- DELETE: Delete a resource |
| `request.ifNoneExist` | [See below](#conditional-batch-actions)                                                                                                                                                        |
| `resource`            | The details of the FHIR resource that is being created/updated.                                                                                                                                |
| `fullUrl`             | [See below](#internal-references)                                                                                                                                                              |

<Accordion title="Example: A simple batch request to simultaneously search for two patients">
  * Typescript
  * CLI
  * cURL

  ```
  await medplum.executeBatch({  resourceType: 'Bundle',  type: 'batch',  entry: [    {      request: {        method: 'GET',        url: 'Patient/homer-simpson',      },    },    {      request: {        method: 'GET',        url: 'Patient/marge-simpson',      },    },  ],});
  ```

  ```
  medplum post Bundle '  {    "resourceType": "Bundle",    "type": "batch",    "entry": [      {        "request": {          "method": "GET",          "url": "Patient/homer-simpson",        },      },      {        "request": {          "method": "GET",          "url": "Patient/marge-simpson",        },      },    ],  }'
  ```

  ```
  curl 'https://api.medplum.com/fhir/R4' \  -X POST  -H 'authorization: Bearer $ACCESS_TOKEN' \  -H 'content-type: application/fhir+json' \  -d '{    "resourceType": "Bundle",    "type": "batch",    "entry": [      {        "request": {          "method": "GET",          "url": "Patient/homer-simpson",        },      },      {        "request": {          "method": "GET",          "url": "Patient/marge-simpson",        },      },    ],  }'
  ```
</Accordion>

<Accordion title="Example: Create multiple resources in one batch request">
  ```
  {  resourceType: 'Bundle',  type: 'batch',  entry: [    {      resource: {        resourceType: 'Patient',        identifier: [          {            system: 'https://example-org.com/patient-ids',            value: 'homer-simpson',          },        ],        name: [          {            family: 'Simpson',            given: ['Homer', 'Jay'],          },        ],      },      request: {        method: 'POST',        url: 'Patient',      },    },    {      resource: {        resourceType: 'Patient',        identifier: [          {            system: 'https://example-org.com/patient-ids',            value: 'marge-simpson',          },        ],        name: [          {            family: 'Simpson',            given: ['Marge', 'Jacqueline'],          },        ],      },      request: {        method: 'POST',        url: 'Patient',      },    },  ],};
  ```
</Accordion>

<Accordion title="Example: Make multiple calls to the _history endpoint in one batch request">
  ```
  {  resourceType: 'Bundle',  type: 'batch',  entry: [    {      request: {        method: 'GET',        url: 'Patient/homer-simpson/_history',      },    },    {      request: {        method: 'GET',        url: 'Patient/marge-simpson/_history',      },    },    {      request: {        method: 'GET',        url: 'Organization/_history',      },    },  ],};
  ```
</Accordion>

### Asynchronous Batch Requests[​](#asynchronous-batch-requests "Direct link to Asynchronous Batch Requests")

Processing very large batches (for example, a `Bundle` over 5 MB in size) can take a significant amount of time, often longer than the default request timeout of one minute. This causes issues with processing the batch, since an error is returned to the client before they can access the actual results of the batch request. To resolve this problem, Medplum offers the ability to process the batch asynchronously: a large `Bundle` (to to 50 MB by default) can be sent to the server, where it will be enqueued for processing, and a response is sent back to the client immediately with a URL where it can receive status updates around the batch processing job.

To opt into asynchronous handling of the batch request, add the `Prefer: respond-async` header to the HTTP request for the batch:

<Tabs>
  <Tab title="cURL">
    ```
    curl 'https://api.medplum.com/fhir/R4' \  -X POST  -H 'authorization: Bearer $ACCESS_TOKEN' \  -H 'content-type: application/fhir+json' \  -H 'prefer: respond-async'  -d @large-bundle.json
    ```
  </Tab>
</Tabs>

See the [FHIR Asynchronous Request pattern](http://hl7.org/fhir/R5/async-bundle.html) for more information.

## Response Structure[​](#response-structure "Direct link to Response Structure")

When you submit a batch request, the server returns a `Bundle` with `type` set to `batch-response` (or `transaction-response` if the request was a transaction).

The response Bundle contains an `entry` array that corresponds one-to-one with the entries in the request Bundle. The order of entries in the response matches the order in the request.

Each entry in the response Bundle contains a `response` element with the following fields:

| Field      | Description                                                                                                              |
| ---------- | ------------------------------------------------------------------------------------------------------------------------ |
| `status`   | The HTTP status code for the operation (e.g., "200", "201", "404").                                                      |
| `outcome`  | An [OperationOutcome](/docs/api/fhir/resources/operationoutcome) resource containing details about the operation result. |
| `location` | For successful create operations, the location of the created resource.                                                  |

If the operation returned a resource (e.g., a `read` or `search` operation, or a `create` operation returning the created resource), it will be included in the `resource` field of the entry.

### Error Handling[​](#error-handling "Direct link to Error Handling")

How errors are handled depends on whether the Bundle is a `batch` or a `transaction`.

**Batch Requests (`type: batch`)**

In a batch request, operations are independent. If one operation fails, it does **not** stop the processing of other operations (unless a system limit like a Rate Limit is reached).

* **Success**: The entry will have a `2xx` status code.
* **Failure**: The entry will have a `4xx` or `5xx` status code. The `response.outcome` will contain an `OperationOutcome` describing the error.

Example of a batch response with one success and one failure:

```
{  "resourceType": "Bundle",  "type": "batch-response",  "entry": [    {      "response": {        "status": "201",        "location": "Patient/123"      },      "resource": {        "resourceType": "Patient",        "id": "123"        // ...      }    },    {      "response": {        "status": "404",        "outcome": {          "resourceType": "OperationOutcome",          "issue": [            {              "severity": "error",              "code": "not-found",              "diagnostics": "Not found"            }          ]        }      }    }  ]}
```

**Transaction Requests (`type: transaction`)**

In a transaction request, operations are atomic. If **any** operation fails, the entire transaction is rolled back, and the server returns an error for the whole request.

* **Success**: All operations succeeded. The response Bundle contains results for all entries.
* **Failure**: The server returns an `OperationOutcome` describing the error that caused the transaction to fail. No partial results are returned.

## References in Bundles[​](#references-in-bundles "Direct link to References in Bundles")

When using batch requests, it is common to require resources to refer to one another: either between two resources within the Bundle, or to resources outside the Bundle. FHIR provides ways to automatically link the resources together, without needing to know the exact resource IDs up front.

### Internal References[​](#internal-references "Direct link to Internal References")

Resources within the same Bundle often need to link to one another: for example, you may create a `Patient` resource that is the `subject` of an `Encounter` created in the same batch request.

Creating internal references is done by assigning temporary IDs to each bundle entry. The `fullUrl` field is set to `'urn:uuid:'` followed by a temporary UUID.

Other bundle entries can refer to this resource using the temporary `urn:uuid:` string, which is replaced by the real reference during batch processing.

<Accordion title="Example: Create a patient and encounter whose subject is the created patient">
  ```
  {  resourceType: 'Bundle',  type: 'transaction',  entry: [    {      fullUrl: 'urn:uuid:f7c8d72c-e02a-4baf-ba04-038c9f753a1c',      resource: {        resourceType: 'Patient',        name: [          {            prefix: ['Ms.'],            family: 'Doe',            given: ['Jane'],          },        ],        gender: 'female',        birthDate: '1970-01-01',      },      request: {        method: 'POST',        url: 'Patient',      },    },    {      fullUrl: 'urn:uuid:7c988bc7-f811-4931-a166-7c1ac5b41a38',      resource: {        resourceType: 'Encounter',        status: 'finished',        class: { code: 'ambulatory' },        subject: {          reference: 'urn:uuid:f7c8d72c-e02a-4baf-ba04-038c9f753a1c',          display: 'Ms. Jane Doe',        },        type: [          {            coding: [              {                system: 'http://snomed.info/sct',                code: '162673000',                display: 'General examination of patient (procedure)',              },            ],          },        ],      },      request: {        method: 'POST',        url: 'Encounter',      },    },  ],};
  ```
</Accordion>

### External (Conditional) References[​](#external-conditional-references "Direct link to External (Conditional) References")

Additionally, it may be necessary to link to resources that already exist on the server outside of the Bundle, for which the ID of the target resource is not known. To handle this use case, FHIR allows populating the reference with a search query string, which will be resolved by Medplum server at resource creation time. This search must resolve to a single resource, otherwise an error will be returned. For example:

<Accordion title="Example: Create multiple patients that link to the same provider">
  ```
  {  resourceType: 'Bundle',  type: 'transaction',  entry: [    {      resource: {        resourceType: 'Patient',        name: [          {            prefix: ['Ms.'],            family: 'Doe',            given: ['Jane'],          },        ],        gender: 'female',        birthDate: '1970-01-01',        generalPractitioner: [{ reference: 'Practitioner?identifier=http://hl7.org/fhir/sid/us-npi|1234567893' }],      },      request: {        method: 'POST',        url: 'Patient',      },    },    {      resource: {        resourceType: 'Patient',        name: [          {            prefix: ['Mr.'],            family: 'Doe',            given: ['John'],          },        ],        gender: 'male',        birthDate: '1972-12-31',        generalPractitioner: [{ reference: 'Practitioner?identifier=http://hl7.org/fhir/sid/us-npi|1234567893' }],      },      request: {        method: 'POST',        url: 'Patient',      },    },  ],};
  ```
</Accordion>

## Conditional Batch Actions[​](#conditional-batch-actions "Direct link to Conditional Batch Actions")

There may be situations where you would only like to create a a resource as part of a batch request if it does not already exist.

You can conditionally perform batch actions by adding the `ifNoneExist` property to the `request` element of your `Bundle`.

The `ifNoneExist` property uses [search parameters](/docs/search/basic-search#search-parameters) to search existing resources and only performs the action if no match is found. Since you are already defining the `url` to send the request to, you only need to enter the actual parameter in this field (i.e., everything that would come after the `?` when submitting an actual search).

<Accordion title="Example: Create a patient and organization, only if the organization does not already exist">
  ```
  {  resourceType: 'Bundle',  type: 'transaction',  entry: [    {      fullUrl: 'urn:uuid:4aac5fb6-c2ff-4851-b3cf-d66d63a82a17',      resource: {        resourceType: 'Organization',        identifier: [          {            system: 'http://example-org.com/organizations',            value: 'example-organization',          },        ],        name: 'Example Organization',      },      request: {        method: 'POST',        url: 'Organization',        ifNoneExist: 'identifier=https://example-org.com/organizations|example-organization',      },    },    {      fullUrl: 'urn:uuid:37b0dfaa-f320-444f-b658-01a04985b2ce',      resource: {        resourceType: 'Patient',        name: [          {            use: 'official',            family: 'Smith',            given: ['Alice'],          },        ],        gender: 'female',        birthDate: '1974-12-15',        managingOrganization: {          reference: 'urn:uuid:4aac5fb6-c2ff-4851-b3cf-d66d63a82a17',          display: 'Example Organization',        },      },      request: {        method: 'POST',        url: 'Patient',      },    },  ],};
  ```
</Accordion>

### Preventing Lost Updates with Version Checking[​](#preventing-lost-updates-with-version-checking "Direct link to Preventing Lost Updates with Version Checking")

When updating resources in a transaction bundle, you can prevent **lost updates** by using the `ifMatch` property in the bundle entry request. This ensures that your update only succeeds if the resource hasn't been modified by another user since you last read it.

<Accordion title="Example: Version Checking in Transaction Bundle">
  * Typescript

  ```
  // Read the current version of resources you want to updateconst patient1 = await medplum.readResource('Patient', 'patient-1');const patient2 = await medplum.readResource('Patient', 'patient-2');// Create a transaction bundle with version checking// Note: Bundle entry ifMatch uses ETag format W/"versionId" because it becomes an HTTP headerconst transactionBundle: Bundle = {  resourceType: 'Bundle',  type: 'transaction',  entry: [    {      request: {        method: 'PUT',        url: 'Patient/patient-1',        // Bundle entries use ETag format: W/"versionId"        // This is different from the SDK updateResource method which uses just the versionId string        ifMatch: patient1.meta?.versionId ? `W/"${patient1.meta.versionId}"` : undefined,      },      resource: {        ...patient1,        name: [{ family: 'Smith', given: ['John'] }],      },    },    {      request: {        method: 'PUT',        url: 'Patient/patient-2',        ifMatch: patient2.meta?.versionId ? `W/"${patient2.meta.versionId}"` : undefined,      },      resource: {        ...patient2,        active: false,      },    },  ],};await medplum.executeBatch(transactionBundle);// If any resource was modified by another user, the transaction will fail with 412 Precondition Failed
  ```
</Accordion>

If any resource in the transaction has been modified by another user (the version doesn't match), the transaction will fail with a `412 Precondition Failed` error, allowing you to retry after re-reading the current state.

## Performing Upserts[​](#performing-upserts "Direct link to Performing Upserts")

Previously, performing an "upsert" (i.e. either creating or updating a resource based on whether it already exists) required using a batch operation. This functionality is now implemented directly as a [conditional update](/docs/fhir-datastore/working-with-fhir#upsert) to provide strong transactional guarantees around the operation in a single, simple `PUT` request.

<Note>
  Because resolving the search request in the upsert URL is a prerequisite to determine which ID should be assigned as part of handling [internal references](#internal-references), the `urn:uuid:` syntax for internal references **cannot** be used in the `Bundle.entry.request.url` for a conditional update within a batch.

  Instead, upsert URLs should link to other resources within the Bundle consistently through conditions on the target resource itself, not its server-assigned ID.

  <Accordion title="Example">
    ❌ **Incorrect**

    ```
    {  "resourceType": "Bundle",  "type": "batch",  "entry": [    {      "fullUrl": "urn:uuid:4410cb87-4a38-4d3f-bee8-3c3556e6debc",      "request": {        "method": "PUT",        "url": "Patient?identifier=http://example.com/mrn|1234567"      },      "resource": {        "resourceType": "Patient",        "identifier": [{ "system": "http://example.com/mrn", "value": "1234567" }]      }    },    {      "fullUrl": "urn:uuid:b122a53c-9c0d-4654-9260-c0b67b7bc5d4",      "request": {        "method": "PUT",        // Incorrect: Upsert URL cannot use replaced urn:uuid: syntax        "url": "CareTeam?subject=urn:uuid:4410cb87-4a38-4d3f-bee8-3c3556e6debc"      },      "resource": {        "resourceType": "CareTeam",        "subject": { "reference": "urn:uuid:4410cb87-4a38-4d3f-bee8-3c3556e6debc" }      }    }  ]}
    ```

    ✅ **Correct**

    ```
    {  "resourceType": "Bundle",  "type": "batch",  "entry": [    {      "fullUrl": "urn:uuid:4410cb87-4a38-4d3f-bee8-3c3556e6debc",      "request": {        "method": "PUT",        "url": "Patient?identifier=http://example.com/mrn|1234567"      },      "resource": {        "resourceType": "Patient",        "identifier": [{ "system": "http://example.com/mrn", "value": "1234567" }]      }    },    {      "fullUrl": "urn:uuid:b122a53c-9c0d-4654-9260-c0b67b7bc5d4",      "request": {        "method": "PUT",        // Correct: Refer to subject via chained search,        // using same identifier as its own upsert URL        "url": "CareTeam?subject.identifier=http://example.com/mrn|1234567"      },      "resource": {        "resourceType": "CareTeam",        "subject": { "reference": "urn:uuid:4410cb87-4a38-4d3f-bee8-3c3556e6debc" }      }    }  ]}
    ```
  </Accordion>
</Note>

## PATCH actions in a Batch[​](#patch-actions-in-a-batch "Direct link to PATCH actions in a Batch")

Because the request body of a PATCH request is an array of [JSON Patch](https://jsonpatch.com/) operations, not a resource, some extra conversion is required to represent these actions in a batch request. The [FHIR recommended pattern](http://hl7.org/fhir/R5/http.html#jsonpatch-transaction) for this use case is to [base64 encode](https://datatracker.ietf.org/doc/html/rfc4648#section-4) the JSON Patch array and represent it as a [Binary](/docs/api/fhir/resources/binary) resource:

```
{  "request": {    "method": "PATCH",    "url": "Patient/6ffaaab4-ff7e-4416-80c7-8fce95c3e31c"  },  "resource": "resource": {    "resourceType": "Binary",    "contentType": "application/json-patch+json",    // Encoded: [{"op":"test","path":"/active","value":false}]    "data": "W3sib3AiOiJyZXBsYWNlIiwicGF0aCI6Ii9hY3RpdmUiLCJ2YWx1ZSI6ZmFsc2V9XQo="  },}
```

Additionally, Medplum supports passing JSON Patch formatted as a [Parameters](/docs/api/fhir/resources/parameters) resource, making it easier to see what operations are happening in the batch.

<Note>
  To avoid parsing ambiguity and simplify the format of the `Parameters`, all values are passed as JSON strings, via the `valueString` field on each corresponding `Parameter.parameter.part` with `"name": "value"`.

  All types of values, including booleans, strings, objects, and arrays, should be passed to `JSON.stringify()` or equivalent rather than being included directly in the `Parameters`.
</Note>

```
{  "request": {    "method": "PATCH",    "url": "Patient/6ffaaab4-ff7e-4416-80c7-8fce95c3e31c"  },  "resource": {    "resourceType": "Parameters",    "parameter": [      {        "name": "operation",        "part": [          { "name": "op", "valueCode": "test" },          { "name": "path", "valueString": "/active" },          { "name": "value", "valueString": "false" }        ]      },      {        "name": "operation",        "part": [          { "name": "op", "valueCode": "add" },          { "name": "path", "valueString": "/name/-" },          // Note that values must be JSON encoded          { "name": "value", "valueString": "{\"given\":[\"Dave\"],\"family\":\"Smith\"}" }        ]      }    ]  }}
```

## Medplum Autobatching[​](#medplum-autobatching "Direct link to Medplum Autobatching")

The Medplum Client provides the option to automatically batch FHIR `read` and `search` requests using the `autoBatchTime` parameter. This field allows you to set a time window during which to batch up any `GET` requests. After this window expires, the `MedplumClient` will add them to a `Bundle` behind the scenes and then execute them as a batch request.

Autobatching works by creating a queue of `Promises` issued within the `autoBatchTime` window and then creating a bundle out of these requests. To allow the queue to be created, you must make sure that the main thread continues to run, so you should not use `await` after each request. Using `await` will pause the main thread each time a request is made, so a queue cannot be created.

Instead you should create the queue of `Promise` requests and then use `Promise.all()` to resolve all of them at once.

<Accordion title="DetailsResolving Promises with autobatching">
  ❌ WRONG

  ```
  // Main thread pauses and waits for Promise to resolve. This request cannot be added to a batchawait medplum.createResource({  resourceType: 'Patient',  name: [    {      family: 'Smith',      given: ['John'],    },  ],});// Main thread pauses and waits for Promise to resolve. This request cannot be added to a batchawait medplum.createResource({  resourceType: 'Patient',  name: [    {      family: 'Simpson',      given: ['Homer', 'Jay'],    },  ],});
  ```

  ✅ CORRECT

  ```
  const patientsToCreate = [];// Main thread continuespatientsToCreate.push(  medplum.createResource({    resourceType: 'Patient',    name: [      {        family: 'Smith',        given: ['John'],      },    ],  }));// Main thread continuespatientsToCreate.push(  medplum.createResource({    resourceType: 'Patient',    name: [      {        family: 'Simpson',        given: ['Homer', 'Jay'],      },    ],  }));// Both promises are resolved simultaneouslyawait Promise.all(patientsToCreate);
  ```
</Accordion>

[Edit this page](https://github.com/medplum/medplum/blob/main/packages/docs/docs/fhir-datastore/fhir-batch-requests.mdx)

Last updated on **Feb 20, 2026**
